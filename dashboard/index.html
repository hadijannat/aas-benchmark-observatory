<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AAS Benchmark Observatory</title>
  <style>
    :root {
      --bg: #0d1117;
      --surface: #161b22;
      --border: #30363d;
      --text: #e6edf3;
      --text-muted: #8b949e;
      --accent: #58a6ff;
      --green: #3fb950;
      --red: #f85149;
      --yellow: #d29922;
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
      background: var(--bg);
      color: var(--text);
      line-height: 1.6;
    }

    header {
      border-bottom: 1px solid var(--border);
      padding: 1.5rem 2rem;
    }

    header h1 { font-size: 1.5rem; font-weight: 600; }
    header p { color: var(--text-muted); font-size: 0.875rem; margin-top: 0.25rem; }

    main { max-width: 1200px; margin: 2rem auto; padding: 0 2rem; }

    .timestamp {
      color: var(--text-muted);
      font-size: 0.8rem;
      margin-bottom: 1.5rem;
    }

    /* Primary tab bar */
    .tab-bar {
      display: flex;
      gap: 0;
      border-bottom: 1px solid var(--border);
      margin-bottom: 1.5rem;
    }

    .tab-btn {
      padding: 0.75rem 1.5rem;
      background: none;
      border: none;
      border-bottom: 2px solid transparent;
      color: var(--text-muted);
      font-size: 0.875rem;
      font-weight: 500;
      cursor: pointer;
      transition: color 0.15s, border-color 0.15s;
    }

    .tab-btn:hover { color: var(--text); }
    .tab-btn.active { color: var(--accent); border-bottom-color: var(--accent); }

    .tab-content { display: none; }
    .tab-content.active { display: block; }

    /* Sub-tab bar (nested within SDK tab) */
    .sub-tab-bar {
      display: flex;
      gap: 0;
      border-bottom: 1px solid var(--border);
      margin-bottom: 1.5rem;
    }

    .sub-tab-btn {
      padding: 0.5rem 1rem;
      background: none;
      border: none;
      border-bottom: 2px solid transparent;
      color: var(--text-muted);
      font-size: 0.8rem;
      font-weight: 500;
      cursor: pointer;
      transition: color 0.15s, border-color 0.15s;
    }

    .sub-tab-btn:hover { color: var(--text); }
    .sub-tab-btn.active { color: var(--accent); border-bottom-color: var(--accent); }

    .sub-tab-content { display: none; }
    .sub-tab-content.active { display: block; }

    /* Cards */
    .sdk-card {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 6px;
      margin-bottom: 1.5rem;
      overflow: hidden;
    }

    .sdk-header {
      padding: 1rem 1.5rem;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    .sdk-header h2 { font-size: 1.1rem; font-weight: 600; }

    .badge {
      font-size: 0.75rem;
      padding: 0.15rem 0.5rem;
      border-radius: 999px;
      font-weight: 500;
    }

    .badge-pass { background: rgba(63, 185, 80, 0.15); color: var(--green); }
    .badge-fail { background: rgba(248, 81, 73, 0.15); color: var(--red); }
    .badge-warn { background: rgba(210, 153, 34, 0.15); color: var(--yellow); }
    .badge-na   { background: rgba(139, 148, 158, 0.15); color: var(--text-muted); }
    .badge-lang {
      background: rgba(88, 166, 255, 0.15);
      color: var(--accent);
      font-size: 0.7rem;
    }

    .sdk-body { padding: 1.5rem; }

    .section-title {
      font-size: 0.8rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--text-muted);
      margin-bottom: 0.75rem;
    }

    .section + .section { margin-top: 1.5rem; }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.875rem;
    }

    th {
      text-align: left;
      padding: 0.5rem 0.75rem;
      border-bottom: 1px solid var(--border);
      color: var(--text-muted);
      font-weight: 500;
    }

    td {
      padding: 0.5rem 0.75rem;
      border-bottom: 1px solid var(--border);
    }

    tr:last-child td { border-bottom: none; }

    td.fastest { color: var(--green); font-weight: 600; }
    td.mem-best { color: var(--green); font-weight: 600; }
    td.mem-worst { color: var(--red); }

    .metric-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
      gap: 1rem;
    }

    .metric-box {
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 0.75rem 1rem;
    }

    .metric-label {
      font-size: 0.75rem;
      color: var(--text-muted);
      margin-bottom: 0.25rem;
    }

    .metric-value {
      font-size: 1.25rem;
      font-weight: 600;
      font-variant-numeric: tabular-nums;
    }

    .loading, .error-msg {
      text-align: center;
      padding: 4rem 2rem;
      color: var(--text-muted);
    }

    .error-msg { color: var(--red); }

    .dataset-section { margin-bottom: 2rem; }
    .dataset-section h3 {
      font-size: 0.95rem;
      font-weight: 600;
      margin-bottom: 0.5rem;
      color: var(--text);
    }
    .dataset-section .meta {
      font-size: 0.75rem;
      color: var(--text-muted);
      margin-bottom: 0.75rem;
    }

    .empty-state {
      text-align: center;
      padding: 3rem 2rem;
      color: var(--text-muted);
    }

    /* Regression indicators */
    .reg-arrow {
      display: inline-block;
      margin-left: 0.35rem;
      font-size: 0.75rem;
      cursor: help;
      position: relative;
    }

    .reg-arrow.regression { color: var(--red); }
    .reg-arrow.improvement { color: var(--green); }

    .reg-arrow .reg-tooltip {
      display: none;
      position: absolute;
      bottom: 125%;
      left: 50%;
      transform: translateX(-50%);
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 4px;
      padding: 0.4rem 0.6rem;
      font-size: 0.7rem;
      white-space: nowrap;
      color: var(--text);
      z-index: 10;
      box-shadow: 0 2px 8px rgba(0,0,0,0.4);
    }

    .reg-arrow:hover .reg-tooltip { display: block; }

    .reg-direction { font-weight: 600; }
    .reg-direction.regression { color: var(--red); }
    .reg-direction.improvement { color: var(--green); }

    .ratio-badge {
      font-size: 0.7rem;
      padding: 0.1rem 0.4rem;
      border-radius: 3px;
      margin-left: 0.35rem;
    }
    .ratio-badge.slow { background: rgba(248, 81, 73, 0.15); color: var(--red); }
    .ratio-badge.fast { background: rgba(63, 185, 80, 0.15); color: var(--green); }
    .ratio-badge.neutral { background: rgba(139, 148, 158, 0.15); color: var(--text-muted); }
  </style>
</head>
<body>
  <header>
    <h1>AAS Benchmark Observatory</h1>
    <p>Automated conformance, performance, and SDK pipeline benchmarks for AAS implementations</p>
  </header>
  <main id="app">
    <div class="loading">Loading results&hellip;</div>
  </main>

  <script>
    const app = document.getElementById('app');

    // ── Constants ──────────────────────────────────────────
    const CORE_OPS = ['deserialize', 'validate', 'traverse', 'update', 'serialize'];
    const XML_OPS = ['deserialize_xml', 'serialize_xml'];
    const AASX_OPS = ['aasx_extract', 'aasx_repackage'];
    const CORE_DATASETS = ['wide', 'deep', 'mixed'];
    const VAL_DATASETS = ['val_regex', 'val_cardinality', 'val_referential'];
    const AASX_DATASETS = ['aasx_small', 'aasx_medium'];

    // ── Helpers ───────────────────────────────────────────
    function esc(s) {
      const d = document.createElement('div');
      d.textContent = String(s ?? '');
      return d.textContent;
    }

    function fmtNs(ns) {
      if (ns == null) return '\u2014';
      if (ns < 1000) return ns.toFixed(0) + ' ns';
      if (ns < 1e6) return (ns / 1e3).toFixed(1) + ' \u00b5s';
      if (ns < 1e9) return (ns / 1e6).toFixed(1) + ' ms';
      return (ns / 1e9).toFixed(2) + ' s';
    }

    function fmtBytes(b) {
      if (b == null) return '\u2014';
      if (b < 1024) return b + ' B';
      if (b < 1024 * 1024) return (b / 1024).toFixed(1) + ' KB';
      if (b < 1024 * 1024 * 1024) return (b / (1024 * 1024)).toFixed(1) + ' MB';
      return (b / (1024 * 1024 * 1024)).toFixed(2) + ' GB';
    }

    function fmtMs(v) { return v != null ? v.toFixed(1) + ' ms' : '\u2014'; }
    function fmtNum(v) { return v != null ? v.toFixed(2) : '\u2014'; }
    function fmtPct(v) { return v != null ? (v >= 0 ? '+' : '') + v.toFixed(1) + '%' : '\u2014'; }

    function metricBox(label, value) {
      const box = document.createElement('div');
      box.className = 'metric-box';
      const lbl = document.createElement('div');
      lbl.className = 'metric-label';
      lbl.textContent = label;
      const val = document.createElement('div');
      val.className = 'metric-value';
      val.textContent = value;
      box.append(lbl, val);
      return box;
    }

    function getPrimaryMemory(opData) {
      const m = opData?.memory;
      if (!m) return null;
      return m.peak_rss_bytes ?? m.traced_peak_bytes ?? m.heap_used_bytes ?? m.alloc_bytes_per_op ?? null;
    }

    // ── Tab switching ─────────────────────────────────────
    function setupTabs() {
      document.querySelectorAll('.tab-bar .tab-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          btn.parentElement.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          document.querySelectorAll('.tab-content').forEach(tc => tc.classList.remove('active'));
          const target = document.getElementById(btn.dataset.tab);
          if (target) target.classList.add('active');
        });
      });
      document.querySelectorAll('.sub-tab-bar .sub-tab-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const bar = btn.parentElement;
          bar.querySelectorAll('.sub-tab-btn').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          const parent = bar.parentElement;
          parent.querySelectorAll(':scope > .sub-tab-content').forEach(tc => tc.classList.remove('active'));
          const target = parent.querySelector('#' + btn.dataset.subtab);
          if (target) target.classList.add('active');
        });
      });
    }

    // ── Regression lookup ─────────────────────────────────
    function buildRegressionLookup(sdkResults) {
      const lookup = {};
      for (const sdk of sdkResults) {
        if (sdk.regressions) {
          for (const reg of sdk.regressions) {
            lookup[sdk.id + '/' + reg.dataset + '/' + reg.operation] = reg;
          }
        }
      }
      return lookup;
    }

    function regressionArrow(reg) {
      if (!reg) return null;
      const span = document.createElement('span');
      span.className = 'reg-arrow ' + reg.direction;
      span.textContent = reg.direction === 'regression' ? '\u25B2' : '\u25BC';
      const tip = document.createElement('span');
      tip.className = 'reg-tooltip';
      tip.textContent = fmtPct(reg.change_pct) + ' (CI: ' + fmtPct(reg.ci_lower_pct) + ' to ' + fmtPct(reg.ci_upper_pct) + ')';
      span.appendChild(tip);
      return span;
    }

    // ── SDK Timing sub-tab ────────────────────────────────
    function buildSdkComparisonTable(dataset, sdkResults, regLookup) {
      const entries = sdkResults
        .filter(s => s.pipeline?.datasets?.[dataset])
        .map(s => ({ id: s.id, name: s.name, lang: s.pipeline.metadata?.language, data: s.pipeline.datasets[dataset] }));

      if (entries.length === 0) return null;

      const section = document.createElement('div');
      section.className = 'dataset-section';

      const h3 = document.createElement('h3');
      h3.textContent = dataset.charAt(0).toUpperCase() + dataset.slice(1) + ' Dataset';
      section.appendChild(h3);

      const firstEntry = entries[0].data;
      if (firstEntry.file_size_bytes || firstEntry.element_count) {
        const meta = document.createElement('div');
        meta.className = 'meta';
        const parts = [];
        if (firstEntry.file_size_bytes) parts.push(fmtBytes(firstEntry.file_size_bytes));
        if (firstEntry.element_count) parts.push(firstEntry.element_count.toLocaleString() + ' elements');
        meta.textContent = parts.join(' \u00b7 ');
        section.appendChild(meta);
      }

      const table = document.createElement('table');
      const thead = document.createElement('thead');
      const headRow = document.createElement('tr');
      const headers = ['Operation', ...entries.map(e => e.name), 'Fastest'];
      for (const h of headers) {
        const th = document.createElement('th');
        th.textContent = h;
        headRow.appendChild(th);
      }
      thead.appendChild(headRow);
      table.appendChild(thead);

      const opSet = new Set();
      for (const e of entries) {
        for (const op of Object.keys(e.data.operations || {})) opSet.add(op);
      }
      const allKnown = [...CORE_OPS, ...XML_OPS, ...AASX_OPS];
      const ops = allKnown.filter(op => opSet.has(op));
      for (const op of opSet) { if (!ops.includes(op)) ops.push(op); }

      const tbody = document.createElement('tbody');
      for (const op of ops) {
        const tr = document.createElement('tr');
        const tdOp = document.createElement('td');
        tdOp.textContent = op;
        tr.appendChild(tdOp);

        let minNs = Infinity;
        let fastestName = '\u2014';
        const values = [];

        for (const entry of entries) {
          const opData = entry.data.operations?.[op];
          const meanNs = opData?.mean_ns;
          values.push(meanNs);
          if (meanNs != null && meanNs < minNs) {
            minNs = meanNs;
            fastestName = entry.name;
          }
        }

        for (let i = 0; i < entries.length; i++) {
          const td = document.createElement('td');
          td.textContent = fmtNs(values[i]);
          if (values[i] != null && values[i] === minNs) {
            td.className = 'fastest';
          }
          if (regLookup) {
            const reg = regLookup[entries[i].id + '/' + dataset + '/' + op];
            const arrow = regressionArrow(reg);
            if (arrow) td.appendChild(arrow);
          }
          tr.appendChild(td);
        }

        const tdFastest = document.createElement('td');
        tdFastest.textContent = fastestName;
        tdFastest.className = 'fastest';
        tr.appendChild(tdFastest);

        tbody.appendChild(tr);
      }
      table.appendChild(tbody);
      section.appendChild(table);
      return section;
    }

    function buildSdkDetailCard(sdk) {
      const card = document.createElement('div');
      card.className = 'sdk-card';

      const header = document.createElement('div');
      header.className = 'sdk-header';
      const h2 = document.createElement('h2');
      h2.textContent = sdk.name || sdk.id;
      header.appendChild(h2);

      const meta = sdk.pipeline?.metadata;
      if (meta?.language) {
        const langBadge = document.createElement('span');
        langBadge.className = 'badge badge-lang';
        langBadge.textContent = meta.language.charAt(0).toUpperCase() + meta.language.slice(1);
        header.appendChild(langBadge);
      }
      card.appendChild(header);

      const body = document.createElement('div');
      body.className = 'sdk-body';

      if (meta) {
        const metaSection = document.createElement('div');
        metaSection.className = 'section';
        const metaTitle = document.createElement('div');
        metaTitle.className = 'section-title';
        metaTitle.textContent = 'SDK Info';
        metaSection.appendChild(metaTitle);

        const metaGrid = document.createElement('div');
        metaGrid.className = 'metric-grid';
        if (meta.runtime_version) metaGrid.appendChild(metricBox('Runtime', meta.runtime_version));
        if (meta.benchmark_harness) metaGrid.appendChild(metricBox('Harness', meta.benchmark_harness));
        if (meta.sdk_package_version) metaGrid.appendChild(metricBox('Package Version', meta.sdk_package_version));
        metaSection.appendChild(metaGrid);
        body.appendChild(metaSection);
      }

      const datasets = sdk.pipeline?.datasets;
      if (datasets) {
        for (const ds of CORE_DATASETS) {
          const dsData = datasets[ds];
          if (!dsData?.operations) continue;

          const section = document.createElement('div');
          section.className = 'section';

          const title = document.createElement('div');
          title.className = 'section-title';
          title.textContent = ds + ' dataset';
          section.appendChild(title);

          const grid = document.createElement('div');
          grid.className = 'metric-grid';

          for (const op of Object.keys(dsData.operations)) {
            const opData = dsData.operations[op];
            if (!opData) continue;
            grid.appendChild(metricBox(op + ' (mean)', fmtNs(opData.mean_ns)));
            if (opData.memory?.peak_rss_bytes) {
              grid.appendChild(metricBox(op + ' (peak RSS)', fmtBytes(opData.memory.peak_rss_bytes)));
            }
          }

          section.appendChild(grid);
          body.appendChild(section);
        }
      }

      const envSection = buildEnvSection(sdk.env);
      if (envSection) body.appendChild(envSection);

      card.appendChild(body);
      return card;
    }

    function renderTimingSubtab(container, sdkResults) {
      if (!sdkResults || sdkResults.length === 0) {
        const empty = document.createElement('div');
        empty.className = 'empty-state';
        empty.textContent = 'No SDK pipeline benchmark results available yet.';
        container.appendChild(empty);
        return;
      }

      const regLookup = buildRegressionLookup(sdkResults);

      for (const ds of CORE_DATASETS) {
        const table = buildSdkComparisonTable(ds, sdkResults, regLookup);
        if (table) container.appendChild(table);
      }

      const detailTitle = document.createElement('div');
      detailTitle.className = 'section-title';
      detailTitle.textContent = 'Per-SDK Details';
      detailTitle.style.marginTop = '2rem';
      container.appendChild(detailTitle);

      for (const sdk of sdkResults) {
        container.appendChild(buildSdkDetailCard(sdk));
      }
    }

    // ── SDK Memory sub-tab ────────────────────────────────
    function buildMemoryTable(dataset, sdkResults) {
      const entries = sdkResults
        .filter(s => s.pipeline?.datasets?.[dataset])
        .map(s => ({ id: s.id, name: s.name, data: s.pipeline.datasets[dataset] }));

      if (entries.length === 0) return null;

      const opSet = new Set();
      for (const e of entries) {
        for (const op of Object.keys(e.data.operations || {})) opSet.add(op);
      }
      const allKnown = [...CORE_OPS, ...XML_OPS, ...AASX_OPS];
      const ops = allKnown.filter(op => opSet.has(op));
      for (const op of opSet) { if (!ops.includes(op)) ops.push(op); }

      let hasAnyMemory = false;
      for (const e of entries) {
        for (const op of ops) {
          if (getPrimaryMemory(e.data.operations?.[op]) != null) {
            hasAnyMemory = true;
            break;
          }
        }
        if (hasAnyMemory) break;
      }
      if (!hasAnyMemory) return null;

      const section = document.createElement('div');
      section.className = 'dataset-section';

      const h3 = document.createElement('h3');
      h3.textContent = dataset.charAt(0).toUpperCase() + dataset.slice(1) + ' Dataset \u2014 Peak Memory';
      section.appendChild(h3);

      const table = document.createElement('table');
      const thead = document.createElement('thead');
      const headRow = document.createElement('tr');
      const headers = ['Operation', ...entries.map(e => e.name), 'Lowest'];
      for (const h of headers) {
        const th = document.createElement('th');
        th.textContent = h;
        headRow.appendChild(th);
      }
      thead.appendChild(headRow);
      table.appendChild(thead);

      const tbody = document.createElement('tbody');
      for (const op of ops) {
        const tr = document.createElement('tr');
        const tdOp = document.createElement('td');
        tdOp.textContent = op;
        tr.appendChild(tdOp);

        let minMem = Infinity;
        let maxMem = -Infinity;
        let lowestName = '\u2014';
        const values = [];

        for (const entry of entries) {
          const mem = getPrimaryMemory(entry.data.operations?.[op]);
          values.push(mem);
          if (mem != null && mem > 0) {
            if (mem < minMem) { minMem = mem; lowestName = entry.name; }
            if (mem > maxMem) { maxMem = mem; }
          }
        }

        for (let i = 0; i < entries.length; i++) {
          const td = document.createElement('td');
          td.textContent = fmtBytes(values[i]);
          if (values[i] != null && values[i] > 0) {
            if (values[i] === minMem && minMem !== maxMem) td.className = 'mem-best';
            else if (values[i] === maxMem && minMem !== maxMem) td.className = 'mem-worst';
          }
          tr.appendChild(td);
        }

        const tdLowest = document.createElement('td');
        tdLowest.textContent = lowestName;
        tdLowest.className = 'mem-best';
        tr.appendChild(tdLowest);

        tbody.appendChild(tr);
      }
      table.appendChild(tbody);
      section.appendChild(table);
      return section;
    }

    function renderMemorySubtab(container, sdkResults) {
      if (!sdkResults || sdkResults.length === 0) {
        const empty = document.createElement('div');
        empty.className = 'empty-state';
        empty.textContent = 'No memory profiling data available yet.';
        container.appendChild(empty);
        return;
      }

      let hasAnyTable = false;
      for (const ds of CORE_DATASETS) {
        const table = buildMemoryTable(ds, sdkResults);
        if (table) { container.appendChild(table); hasAnyTable = true; }
      }

      if (!hasAnyTable) {
        const empty = document.createElement('div');
        empty.className = 'empty-state';
        empty.textContent = 'No memory profiling data available. Memory metrics will appear after the next benchmark run.';
        container.appendChild(empty);
      }
    }

    // ── SDK Validation sub-tab ────────────────────────────
    function renderValidationSubtab(container, sdkResults) {
      if (!sdkResults || sdkResults.length === 0) {
        const empty = document.createElement('div');
        empty.className = 'empty-state';
        empty.textContent = 'No validation analysis data available yet.';
        container.appendChild(empty);
        return;
      }

      const entries = sdkResults.filter(s => {
        const ds = s.pipeline?.datasets;
        if (!ds) return false;
        return VAL_DATASETS.some(vd => ds[vd]?.operations?.validate);
      }).map(s => ({ id: s.id, name: s.name, datasets: s.pipeline.datasets }));

      if (entries.length === 0) {
        const empty = document.createElement('div');
        empty.className = 'empty-state';
        empty.textContent = 'No targeted validation datasets found. Run benchmarks with validation target datasets (val_regex, val_cardinality, val_referential).';
        container.appendChild(empty);
        return;
      }

      const desc = document.createElement('p');
      desc.style.cssText = 'color: var(--text-muted); font-size: 0.85rem; margin-bottom: 1.5rem;';
      desc.textContent = 'Validation performance on targeted datasets that stress specific constraint categories. Ratios compare against the mixed baseline dataset.';
      container.appendChild(desc);

      const section = document.createElement('div');
      section.className = 'dataset-section';

      const h3 = document.createElement('h3');
      h3.textContent = 'Validate Operation \u2014 Targeted Datasets';
      section.appendChild(h3);

      const table = document.createElement('table');
      const thead = document.createElement('thead');
      const headRow = document.createElement('tr');
      const headers = ['Dataset', ...entries.map(e => e.name)];
      for (const h of headers) {
        const th = document.createElement('th');
        th.textContent = h;
        headRow.appendChild(th);
      }
      thead.appendChild(headRow);
      table.appendChild(thead);

      const mixedBaseline = {};
      for (const e of entries) {
        const mixedValidate = e.datasets?.mixed?.operations?.validate?.mean_ns;
        if (mixedValidate) mixedBaseline[e.id] = mixedValidate;
      }

      const tbody = document.createElement('tbody');

      // Mixed baseline row
      const trBaseline = document.createElement('tr');
      const tdBaselineLabel = document.createElement('td');
      tdBaselineLabel.textContent = 'mixed ';
      const baselineNote = document.createElement('span');
      baselineNote.style.cssText = 'color:var(--text-muted);font-size:0.75rem';
      baselineNote.textContent = '(baseline)';
      tdBaselineLabel.appendChild(baselineNote);
      trBaseline.appendChild(tdBaselineLabel);
      for (const entry of entries) {
        const td = document.createElement('td');
        const val = entry.datasets?.mixed?.operations?.validate?.mean_ns;
        td.textContent = fmtNs(val);
        trBaseline.appendChild(td);
      }
      tbody.appendChild(trBaseline);

      const valLabels = {
        'val_regex': 'Regex Patterns',
        'val_cardinality': 'Cardinality Edges',
        'val_referential': 'Cross-References',
      };

      for (const vd of VAL_DATASETS) {
        const tr = document.createElement('tr');
        const tdLabel = document.createElement('td');
        tdLabel.textContent = valLabels[vd] || vd;
        tr.appendChild(tdLabel);

        for (const entry of entries) {
          const td = document.createElement('td');
          const val = entry.datasets?.[vd]?.operations?.validate?.mean_ns;
          td.textContent = fmtNs(val);

          const baseline = mixedBaseline[entry.id];
          if (val != null && baseline != null && baseline > 0) {
            const ratio = val / baseline;
            const ratioBadge = document.createElement('span');
            ratioBadge.className = 'ratio-badge ' + (ratio > 1.5 ? 'slow' : ratio < 0.7 ? 'fast' : 'neutral');
            ratioBadge.textContent = ratio.toFixed(1) + 'x';
            td.appendChild(ratioBadge);
          }
          tr.appendChild(td);
        }
        tbody.appendChild(tr);
      }

      table.appendChild(tbody);
      section.appendChild(table);
      container.appendChild(section);
    }

    // ── SDK AASX sub-tab ──────────────────────────────────
    function renderAasxSubtab(container, sdkResults) {
      if (!sdkResults || sdkResults.length === 0) {
        const empty = document.createElement('div');
        empty.className = 'empty-state';
        empty.textContent = 'No AASX benchmark data available yet.';
        container.appendChild(empty);
        return;
      }

      const entries = sdkResults.filter(s => {
        const ds = s.pipeline?.datasets;
        if (!ds) return false;
        return AASX_DATASETS.some(ad => ds[ad] && Object.keys(ds[ad].operations || {}).some(op => AASX_OPS.includes(op)));
      }).map(s => ({ id: s.id, name: s.name, datasets: s.pipeline.datasets }));

      if (entries.length === 0) {
        const empty = document.createElement('div');
        empty.className = 'empty-state';
        empty.textContent = 'No SDKs have AASX benchmark results. AASX packaging benchmarks require datasets generated with --aasx flag.';
        container.appendChild(empty);
        return;
      }

      const desc = document.createElement('p');
      desc.style.cssText = 'color: var(--text-muted); font-size: 0.85rem; margin-bottom: 1.5rem;';
      desc.textContent = 'AASX packaging benchmarks measure extraction (reading) and repackaging (writing) of OPC-based AAS packages.';
      container.appendChild(desc);

      for (const ad of AASX_DATASETS) {
        const section = document.createElement('div');
        section.className = 'dataset-section';

        const h3 = document.createElement('h3');
        h3.textContent = ad.replace('_', ' ').replace(/\b\w/g, c => c.toUpperCase());
        section.appendChild(h3);

        const table = document.createElement('table');
        const thead = document.createElement('thead');
        const headRow = document.createElement('tr');
        const headers = ['Operation', ...entries.map(e => e.name)];
        for (const h of headers) {
          const th = document.createElement('th');
          th.textContent = h;
          headRow.appendChild(th);
        }
        thead.appendChild(headRow);
        table.appendChild(thead);

        const tbody = document.createElement('tbody');
        let hasData = false;

        for (const op of AASX_OPS) {
          const tr = document.createElement('tr');
          const tdOp = document.createElement('td');
          tdOp.textContent = op;
          tr.appendChild(tdOp);

          for (const entry of entries) {
            const td = document.createElement('td');
            const opData = entry.datasets?.[ad]?.operations?.[op];
            const meanNs = opData?.mean_ns;
            td.textContent = fmtNs(meanNs);
            if (meanNs != null) hasData = true;

            const mem = getPrimaryMemory(opData);
            if (mem != null) {
              const memSpan = document.createElement('div');
              memSpan.style.cssText = 'font-size:0.7rem;color:var(--text-muted);';
              memSpan.textContent = fmtBytes(mem) + ' mem';
              td.appendChild(memSpan);
            }
            tr.appendChild(td);
          }
          tbody.appendChild(tr);
        }

        if (hasData) {
          table.appendChild(tbody);
          section.appendChild(table);
          container.appendChild(section);
        }
      }
    }

    // ── SDK Regressions sub-tab ───────────────────────────
    function renderRegressionsSubtab(container, sdkResults) {
      const allRegs = [];
      for (const sdk of sdkResults) {
        if (sdk.regressions) {
          for (const reg of sdk.regressions) {
            allRegs.push({ sdkName: sdk.name, sdkId: sdk.id, ...reg });
          }
        }
      }

      if (allRegs.length === 0) {
        const empty = document.createElement('div');
        empty.className = 'empty-state';
        empty.textContent = 'No regressions or improvements detected. Regression detection requires a previous results.json for comparison.';
        container.appendChild(empty);
        return;
      }

      const desc = document.createElement('p');
      desc.style.cssText = 'color: var(--text-muted); font-size: 0.85rem; margin-bottom: 1.5rem;';
      desc.textContent = allRegs.length + ' significant change(s) detected against the previous benchmark run (95% confidence, >5% threshold).';
      container.appendChild(desc);

      const regCount = allRegs.filter(r => r.direction === 'regression').length;
      const impCount = allRegs.filter(r => r.direction === 'improvement').length;
      const summaryGrid = document.createElement('div');
      summaryGrid.className = 'metric-grid';
      summaryGrid.style.marginBottom = '1.5rem';
      summaryGrid.appendChild(metricBox('Regressions', String(regCount)));
      summaryGrid.appendChild(metricBox('Improvements', String(impCount)));
      container.appendChild(summaryGrid);

      const table = document.createElement('table');
      const thead = document.createElement('thead');
      const headRow = document.createElement('tr');
      for (const h of ['SDK', 'Dataset', 'Operation', 'Previous', 'Current', 'Change', 'CI (95%)', 'Direction']) {
        const th = document.createElement('th');
        th.textContent = h;
        headRow.appendChild(th);
      }
      thead.appendChild(headRow);
      table.appendChild(thead);

      const tbody = document.createElement('tbody');
      for (const r of allRegs) {
        const tr = document.createElement('tr');
        const cells = [
          r.sdkName,
          r.dataset,
          r.operation,
          fmtNs(r.previous_mean_ns),
          fmtNs(r.current_mean_ns),
          fmtPct(r.change_pct),
          fmtPct(r.ci_lower_pct) + ' to ' + fmtPct(r.ci_upper_pct),
        ];
        for (const c of cells) {
          const td = document.createElement('td');
          td.textContent = c;
          tr.appendChild(td);
        }
        const tdDir = document.createElement('td');
        const dirSpan = document.createElement('span');
        dirSpan.className = 'reg-direction ' + r.direction;
        dirSpan.textContent = r.direction === 'regression' ? '\u25B2 Regression' : '\u25BC Improvement';
        tdDir.appendChild(dirSpan);
        tr.appendChild(tdDir);
        tbody.appendChild(tr);
      }
      table.appendChild(tbody);
      container.appendChild(table);
    }

    // ── SDK tab (with sub-tabs) ───────────────────────────
    function renderSdkTab(container, sdkResults) {
      if (!sdkResults || sdkResults.length === 0) {
        const empty = document.createElement('div');
        empty.className = 'empty-state';
        empty.textContent = 'No SDK pipeline benchmark results available yet.';
        container.appendChild(empty);
        return;
      }

      const subBar = document.createElement('div');
      subBar.className = 'sub-tab-bar';
      const subTabs = [
        { id: 'subtab-timing', label: 'Timing' },
        { id: 'subtab-memory', label: 'Memory' },
        { id: 'subtab-validation', label: 'Validation' },
        { id: 'subtab-aasx', label: 'AASX' },
        { id: 'subtab-regressions', label: 'Regressions' },
      ];
      for (let i = 0; i < subTabs.length; i++) {
        const btn = document.createElement('button');
        btn.className = 'sub-tab-btn' + (i === 0 ? ' active' : '');
        btn.textContent = subTabs[i].label;
        btn.dataset.subtab = subTabs[i].id;
        subBar.appendChild(btn);
      }
      container.appendChild(subBar);

      const timingContent = document.createElement('div');
      timingContent.id = 'subtab-timing';
      timingContent.className = 'sub-tab-content active';
      renderTimingSubtab(timingContent, sdkResults);
      container.appendChild(timingContent);

      const memoryContent = document.createElement('div');
      memoryContent.id = 'subtab-memory';
      memoryContent.className = 'sub-tab-content';
      renderMemorySubtab(memoryContent, sdkResults);
      container.appendChild(memoryContent);

      const validationContent = document.createElement('div');
      validationContent.id = 'subtab-validation';
      validationContent.className = 'sub-tab-content';
      renderValidationSubtab(validationContent, sdkResults);
      container.appendChild(validationContent);

      const aasxContent = document.createElement('div');
      aasxContent.id = 'subtab-aasx';
      aasxContent.className = 'sub-tab-content';
      renderAasxSubtab(aasxContent, sdkResults);
      container.appendChild(aasxContent);

      const regContent = document.createElement('div');
      regContent.id = 'subtab-regressions';
      regContent.className = 'sub-tab-content';
      renderRegressionsSubtab(regContent, sdkResults);
      container.appendChild(regContent);
    }

    // ── Server API Benchmarks tab ─────────────────────────
    function getConformanceStatus(conf) {
      if (!conf) return { cls: 'na', label: 'No data' };
      const passed = conf.checks_passed ?? 0;
      const total = conf.checks_total ?? 0;
      if (total === 0) return { cls: 'na', label: 'No checks' };
      if (passed === total) return { cls: 'pass', label: passed + '/' + total + ' passed' };
      if (passed === 0) return { cls: 'fail', label: '0/' + total + ' passed' };
      const pct = Math.round((passed / total) * 100);
      return { cls: pct >= 70 ? 'warn' : 'fail', label: passed + '/' + total + ' passed (' + pct + '%)' };
    }

    function buildConformanceSection(conf) {
      if (!conf) return null;
      const section = document.createElement('div');
      section.className = 'section';

      const title = document.createElement('div');
      title.className = 'section-title';
      const totalPassed = conf.checks_passed ?? 0;
      const totalChecks = conf.checks_total ?? 0;
      title.textContent = 'Conformance \u2014 ' + totalPassed + '/' + totalChecks + ' checks passed across ' + (conf.total_profiles || 0) + ' profiles';
      section.appendChild(title);

      const table = document.createElement('table');
      const thead = document.createElement('thead');
      const headRow = document.createElement('tr');
      for (const h of ['Profile', 'Description', 'Checks Passed', 'Status']) {
        const th = document.createElement('th');
        th.textContent = h;
        headRow.appendChild(th);
      }
      thead.appendChild(headRow);
      table.appendChild(thead);

      const tbody = document.createElement('tbody');
      if (conf.results && conf.results.length > 0) {
        for (const r of conf.results) {
          const tr = document.createElement('tr');
          const td1 = document.createElement('td');
          td1.textContent = r.suite || r.profile || r.name || '\u2014';
          const td2 = document.createElement('td');
          td2.textContent = r.description || '\u2014';
          const td3 = document.createElement('td');
          const rPassed = r.checks_passed ?? 0;
          const rTotal = r.checks_total ?? 0;
          td3.textContent = rTotal > 0 ? rPassed + '/' + rTotal : '\u2014';
          const td4 = document.createElement('td');
          const badge = document.createElement('span');
          if (rTotal === 0) {
            badge.className = 'badge badge-na';
            badge.textContent = 'N/A';
          } else if (rPassed === rTotal) {
            badge.className = 'badge badge-pass';
            badge.textContent = 'Pass';
          } else {
            const pct = Math.round((rPassed / rTotal) * 100);
            badge.className = 'badge badge-' + (pct >= 70 ? 'warn' : 'fail');
            badge.textContent = pct + '%';
          }
          td4.appendChild(badge);
          tr.append(td1, td2, td3, td4);
          tbody.appendChild(tr);
        }
      } else {
        const tr = document.createElement('tr');
        const td = document.createElement('td');
        td.colSpan = 4;
        td.textContent = 'No profile details';
        tr.appendChild(td);
        tbody.appendChild(tr);
      }
      table.appendChild(tbody);
      section.appendChild(table);
      return section;
    }

    function buildBenchmarksSection(benchmarks) {
      if (!benchmarks) return null;
      const section = document.createElement('div');
      section.className = 'section';

      const title = document.createElement('div');
      title.className = 'section-title';
      title.textContent = 'Performance';
      section.appendChild(title);

      const grid = document.createElement('div');
      grid.className = 'metric-grid';

      if (benchmarks.scenarios?.metrics) {
        const m = benchmarks.scenarios.metrics;
        const dur = m.http_req_duration?.values;
        grid.appendChild(metricBox('HTTP Req Duration (p95)', dur?.['p(95)'] != null ? dur['p(95)'].toFixed(1) + ' ms' : '\u2014'));
        grid.appendChild(metricBox('HTTP Req Duration (med)', dur?.med != null ? dur.med.toFixed(1) + ' ms' : '\u2014'));
        grid.appendChild(metricBox('Requests/sec', m.http_reqs?.values?.rate != null ? m.http_reqs.values.rate.toFixed(2) : '\u2014'));
        const checks = m.checks?.values;
        const checkRate = checks ? (checks.passes ?? 0) + '/' + ((checks.passes ?? 0) + (checks.fails ?? 0)) : '\u2014';
        grid.appendChild(metricBox('Checks Passed', checkRate));
      }

      if (benchmarks.crud?.metrics) {
        const m = benchmarks.crud.metrics;
        const dur = m.http_req_duration?.values;
        grid.appendChild(metricBox('CRUD Duration (p95)', dur?.['p(95)'] != null ? dur['p(95)'].toFixed(1) + ' ms' : '\u2014'));
        grid.appendChild(metricBox('CRUD Duration (med)', dur?.med != null ? dur.med.toFixed(1) + ' ms' : '\u2014'));
        grid.appendChild(metricBox('CRUD Requests/sec', m.http_reqs?.values?.rate != null ? m.http_reqs.values.rate.toFixed(2) : '\u2014'));
      }

      section.appendChild(grid);
      return section;
    }

    function buildEnvSection(env) {
      if (!env) return null;
      const section = document.createElement('div');
      section.className = 'section';

      const title = document.createElement('div');
      title.className = 'section-title';
      title.textContent = 'Runner Environment';
      section.appendChild(title);

      const table = document.createElement('table');
      const tbody = document.createElement('tbody');
      const rows = [
        ['CPU', (env.cpu_count || '\u2014') + ' cores'],
        ['Memory', (env.total_memory_mb || '\u2014') + ' MB'],
        ['Docker', env.docker_version || '\u2014'],
        ['OS / Arch', (env.os || '\u2014') + ' / ' + (env.arch || '\u2014')],
      ];
      for (const [label, value] of rows) {
        const tr = document.createElement('tr');
        const td1 = document.createElement('td');
        td1.textContent = label;
        const td2 = document.createElement('td');
        td2.textContent = value;
        tr.append(td1, td2);
        tbody.appendChild(tr);
      }
      table.appendChild(tbody);
      section.appendChild(table);
      return section;
    }

    function renderServerTab(container, serverResults) {
      if (!serverResults || serverResults.length === 0) {
        const empty = document.createElement('div');
        empty.className = 'empty-state';
        empty.textContent = 'No server benchmark results available yet.';
        container.appendChild(empty);
        return;
      }

      for (const srv of serverResults) {
        const card = document.createElement('div');
        card.className = 'sdk-card';

        const header = document.createElement('div');
        header.className = 'sdk-header';
        const h2 = document.createElement('h2');
        h2.textContent = srv.name || srv.id;
        header.appendChild(h2);

        const confStatus = getConformanceStatus(srv.conformance);
        const badge = document.createElement('span');
        badge.className = 'badge badge-' + confStatus.cls;
        badge.textContent = confStatus.label;
        header.appendChild(badge);
        card.appendChild(header);

        const body = document.createElement('div');
        body.className = 'sdk-body';

        const confSection = buildConformanceSection(srv.conformance);
        if (confSection) body.appendChild(confSection);

        const benchSection = buildBenchmarksSection(srv.benchmarks);
        if (benchSection) body.appendChild(benchSection);

        const envSection = buildEnvSection(srv.env);
        if (envSection) body.appendChild(envSection);

        card.appendChild(body);
        container.appendChild(card);
      }
    }

    // ── Main render ───────────────────────────────────────
    function render(data) {
      app.replaceChildren();

      const ts = document.createElement('p');
      ts.className = 'timestamp';
      ts.textContent = 'Last updated: ' + new Date(data.generated_at).toLocaleString();
      app.appendChild(ts);

      const sdkResults = (data.sdk_benchmarks || []).map(s => {
        if (s.pipeline && !s.pipeline.datasets && !s.pipeline.schema_version) {
          s.pipeline = { datasets: s.pipeline, metadata: {} };
        }
        return s;
      });
      const serverResults = data.server_benchmarks || data.sdks || [];

      const tabBar = document.createElement('div');
      tabBar.className = 'tab-bar';

      const sdkBtn = document.createElement('button');
      sdkBtn.className = 'tab-btn active';
      sdkBtn.textContent = 'SDK Pipeline Benchmarks';
      sdkBtn.dataset.tab = 'tab-sdk';

      const srvBtn = document.createElement('button');
      srvBtn.className = 'tab-btn';
      srvBtn.textContent = 'Server API Benchmarks';
      srvBtn.dataset.tab = 'tab-server';

      tabBar.append(sdkBtn, srvBtn);
      app.appendChild(tabBar);

      const sdkTab = document.createElement('div');
      sdkTab.id = 'tab-sdk';
      sdkTab.className = 'tab-content active';
      renderSdkTab(sdkTab, sdkResults);
      app.appendChild(sdkTab);

      const srvTab = document.createElement('div');
      srvTab.id = 'tab-server';
      srvTab.className = 'tab-content';
      renderServerTab(srvTab, serverResults);
      app.appendChild(srvTab);

      if (sdkResults.length === 0 && serverResults.length > 0) {
        sdkBtn.classList.remove('active');
        srvBtn.classList.add('active');
        sdkTab.classList.remove('active');
        srvTab.classList.add('active');
      }

      setupTabs();
    }

    async function loadResults() {
      try {
        const res = await fetch('data/results.json');
        if (!res.ok) throw new Error('HTTP ' + res.status);
        const data = await res.json();
        render(data);
      } catch (err) {
        app.replaceChildren();
        const errDiv = document.createElement('div');
        errDiv.className = 'error-msg';
        errDiv.textContent = 'Could not load results. Run the benchmark workflow first.';
        const small = document.createElement('small');
        small.textContent = err.message;
        errDiv.appendChild(document.createElement('br'));
        errDiv.appendChild(small);
        app.appendChild(errDiv);
      }
    }

    loadResults();
  </script>
</body>
</html>
